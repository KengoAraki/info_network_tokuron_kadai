# -*- coding: utf-8 -*-
"""enshu2-1.ipynb

Automatically generated by Colaboratory.

Original file is located at
	https://colab.research.google.com/drive/1P23Rs-B68hozUQtIUDAumIjUBx5UIZpT

## 第2回　データリンク層　演習2
Radix Treeを用いた経路表管理のプログラム

! pip install py-radix
! pip install tqdm
"""

"""　py-radix を用いる手法　"""

# import radix
# import re

# class IPAddr(object):
#     def __init__(self, route_file):
#         self.route_file = route_file
#         self.rtree = radix.Radix()

#     def load_route(self):
#         f = open(self.route_file,"r")
		
#         self.idx_table = []
#         for (idx, line) in enumerate(f):
#             line = line.strip()

#             addr = self._extract_address(line)
	
#             if addr is not None:
#                 self.rtree.add(addr)
#             else:
#                 print("addr for [{}] will be None".format(line))
#             self.idx_table.append([idx, addr])

#     def search(self, addr):
#         rnode = self.rtree.search_best(addr)
#         if(str(rnode) is not None):
#             for row in self.idx_table:
#                 if(row[1] == rnode.prefix):
#                     print(str(addr) + "\tIndex:" + str(row[0]) + ", NetAddr:" + str(row[1]))

#     def _extract_address(self, addr):
#         _addr = re.split('/', addr)
#         dot_num = _addr[0].count('.')
		
#         for i in range(3 - dot_num):
#             _addr[0] = _addr[0] + ".0"

#         if (len(_addr) == 2) and ((len(_addr[1]) == 2) or (len(_addr[1]) == 1)):
#             interp_addr = _addr[0] + "/" + _addr[1]
#         else:
#             interp_addr = None
#         return interp_addr

# def main():
#     route_file = "route-02.txt"
#     ipaddr = IPAddr(route_file)
	
#     print("== load route ==")
#     ipaddr.load_route()

#     print("== search network address ==")
#     for addr in s_list:
#         ipaddr.search(addr)

# main()

""" 自作基数木を使用した方法"""

import re
from tqdm import tqdm

class Node(object):
	def __init__(self, value=None, left=None, right=None, depth=None):
		self.value = value
		self.left = left
		self.right = right
		self.depth = depth


class BT(object):
	def __init__(self):
		self.root = Node("0.0.0.0/0", depth=0)
		self.max_depth = 0

	def add(self, net_addr):
		# アドレス部とプレフィックス長に分割
		addr, pref_len = self._split_addr(net_addr)
		# 10進数->2進数
		bin_addr = self._ten2bin(addr)
		current_node = self.root

		for i in range(pref_len):
			depth = i + 1
			if i == (pref_len - 1):
				value = net_addr
				left = None
				right = None
			else:
				if bin_addr[i] == '0':
					_node = current_node.left
				elif bin_addr[i] == '1':
					_node = current_node.right
				value, left, right = self._node_attr(_node)

			if bin_addr[i] == '0':
				current_node.left = Node(value=value, left=left, right=right, depth=depth)
				current_node = current_node.left
			elif bin_addr[i] == '1':
				current_node.right = Node(value=value, left=left, right=right, depth=depth)
				current_node = current_node.right
	
		if self.max_depth < depth:
			self.max_depth = depth

	def search_best(self, addr):
		# 10進数->2進数
		bin_addr = self._ten2bin(addr)
		current_node = self.root
		best_node = None

		for i in range(32):
			if bin_addr[i] == '0':
				current_node = current_node.left
			elif bin_addr[i] == '1':
				current_node = current_node.right
			
			if current_node is not None:
				if current_node.value is not None:
					best_node = current_node
				else:
					continue
			else:
				break
		return best_node

	def _node_attr(self, node):
		if node is not None:
			value = node.value
			left = node.left
			right = node.right
		else:
			value = None
			left = None
			right = None
		return value, left, right

	# net_addr: prefix長つきのアドレス
	def _split_addr(self, net_addr):
		_net_addr = re.split('/', net_addr)
		addr = _net_addr[0]
		pref_len = _net_addr[1]
		return addr, int(pref_len)

	# addr: prefix長なしのアドレス
	def _ten2bin(self, addr):
		dot_num = addr.count('.')
		for i in range(3 - dot_num):
			addr = addr + ".0"
		sp_addr = re.split('\.', addr)

		bin_addrs = []
		for (i, sp) in enumerate(sp_addr):
			bin_addrs.append(format(int(sp), '08b'))

		return bin_addrs[0] + bin_addrs[1] + bin_addrs[2] + bin_addrs[3]


class IPAddr(object):
	def __init__(self, route_file):
		self.route_file = route_file
		self.rtree = BT()

	def load_route(self):
		f = open(self.route_file,"r")

		self.idx_table = []
		num_lines = sum(1 for line in open(self.route_file,'r'))
		for (idx, line) in enumerate(tqdm(f, total=num_lines)):
			line = line.strip()
			addr = self._extract_address(line)

			if addr is not None:
				self.rtree.add(addr)
			else:
				print("addr for [{}] will be None".format(line))
			self.idx_table.append([idx, addr])

	def search(self, addr):
		rnode = self.rtree.search_best(addr)
		if(rnode is not None):
			for row in self.idx_table:
				if(row[1] == rnode.value):
					print(str(addr) + "\tIndex:" + str(row[0]) + ", NetAddr:" + str(row[1]))

	def _extract_address(self, addr):
		_addr = re.split('/', addr)
		dot_num = _addr[0].count('.')
		
		for i in range(3 - dot_num):
			_addr[0] = _addr[0] + ".0"

		if (len(_addr) == 2) and ((len(_addr[1]) == 2) or (len(_addr[1]) == 1)):
			interp_addr = _addr[0] + "/" + _addr[1]
		else:
			interp_addr = None
		return interp_addr


def main():
	# search: host IP address
	s_list = ["41.74.1.1", "66.31.10.3", "133.5.1.1", "209.143.75.1", "221.121.128.1"]
	route_file = "route-02.txt"
	ipaddr = IPAddr(route_file)

	print("== load route ==")
	ipaddr.load_route()

	print("== search network address ==")

	for addr in s_list:
		ipaddr.search(addr)


if __name__ == "__main__":
	main()
